"""
    Liouville-Lanczos: A library for Many-Body Green's function on quantum and classical computer.
    Copyright (C) 2024  Alexandre Foley

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
import quimb.tensor as qtn
import numpy as np
from typing import List


def retag(X: qtn.Tensor, tags):
	X.drop_tags()
	for tag in tags:
		X.add_tag(tag)


def layer_SVD_optimizer(
	layer: qtn.TensorNetwork,
	layer_left_indices: list[str],
	accu: qtn.MatrixProductOperator,
	mpo: qtn.MatrixProductOperator,
	Layer_tag_id: str,
	max_it: int,
	prec: float,
	*,
	renorm: bool = True,
	return_error: bool = False
):
	n = mpo.L
	# layer_left_output_inds = set([mpo.lower_ind_id.format(i) for i in range(n)])
	# accu_left_inds = set(accu.upper_ind_id.format(i) for i in range(n) )
	Ntens = len(layer.tensors)
	layertags = [Layer_tag_id.format(i) for i in range(Ntens)]
	err = 1000
	it = 0
	direction = 1
	pos = 0
	Ltags = [Layer_tag_id.format(pos) for pos in range(Ntens)]
	curr_err = 1e6
	while it < max_it and curr_err > prec:
		it += 1
		# print("direction ",direction)
		for i in range(Ntens):
			curr_A = Ltags[pos]
			# print("tensor to update: ",curr_A)
			accuH = accu.H
			if renorm:
				for t in accuH.tensors[:-2]:
					t /= 2
			X = mpo | accu.H | layer.H
			# X.draw()
			TBDtags = set(X.tags).difference(layer[curr_A].tags)
			TBd = X.contract(TBDtags)
			update_tags = set(TBd.tags).difference(layer[curr_A].tags)
			T = TBd.contract(update_tags)
			T = T[update_tags]
			left_inds = layer_left_indices[curr_A]
			U, d, V = T.split(left_inds, cutoff=0.0, absorb=None)  # normalize...
			T = U @ V
			# print(T@T.H)
			E = layer[curr_A] - T  # Better error computation is possible.
			err = (d - 1).sum_reduce(d.inds[0]).data
			retag(T, layer[curr_A].tags)
			layer[curr_A] = T
			# upd,d = layer_upd(B,H,layer[curr_A],oli,iri)
			pos += direction
		if abs(err) < prec:
			break
		curr_err = err
		##
		direction *= -1
		pos += direction
		# print(iterative_projection_infidelity(T.select_any(layertags),accu,mpo))
		# print(iterative_projection_infidelity(normalize_gates(T.select_any(layertags)),accu,mpo))
	if return_error:
		return layer.select_any(layertags), curr_err
	return layer.select_any(layertags)


class Env_holder:
	"""
	class to hold the MPTs that makes up the enviroments of a 1d-sweeping tensor algorithm.
	Takes care of the fiddling with the site index. The environment generated by the tensors at site i can be accessed by using [j,i] where j is the jth environment List
	"""

	def __init__(self, env):
		self.env = env

	def __getitem__(self, i: tuple[int, int]):
		i, j = i
		return self.env[i][j + 1]

	def __setitem__(self, i: tuple[int, int], value):
		i, j = i
		self.env[i][j + 1] = value


def mpsmps_env_prep(mpsA: qtn.MatrixProductState, mpsB: qtn.MatrixProductState):
	outleft = []
	outleft.append(qtn.Tensor(data=1, inds=()))
	oc = mpsA.calc_current_orthog_center()
	if oc[0] == oc[1]:
		oc = oc[0]
	else:
		oc = mpsA.L - 1
	for i in range(oc):
		outleft.append((outleft[-1] | mpsA[i].H | mpsB[i]).contract())
	outright = []
	outright.append(qtn.Tensor(data=1, inds=()))
	for i in range(mpsA.L - oc - 1):
		outright.append((outright[-1] | mpsA[-i - 1].H | mpsB[-i - 1]).contract())
	outright.reverse()
	return outleft + [qtn.Tensor()] + outright


def sum_sweep(
	MPSes: List[qtn.MatrixProductState],
	target: qtn.MatrixProductState,
	envs,
	direction,
	tol,
	oc,
):
	Env = Env_holder(envs)
	starting_oc = oc
	L = target.L
	if oc == 0:
		direction = -1
	if oc == L - 1:
		direction = 1
	while True:
		direction = direction - 2 * (oc == (L - 1) or oc == 0) * direction
		if direction == 1:
			Tens = (
				Env[0, oc - 1] | MPSes[0][oc] | MPSes[0][oc + 1] | Env[0, oc + 2]
			).contract()
			for i, t in enumerate(MPSes[1:]):
				Tens += (
					Env[i + 1, oc - 1]
					| MPSes[i + 1][oc]
					| MPSes[i + 1][oc + 1]
					| Env[i + 1, oc + 2]
				).contract()
			n = len(MPSes[0][oc + 1].inds) - 1
			U, d, V = qtn.tensor_split(
				Tens, right_inds=Tens.inds[-n:], left_inds=None, absorb=None, cutoff=tol
			)
			U.drop_tags()
			for tag in target[oc].tags:
				U.add_tag(tag)
			target[oc] = U
			for i, t in enumerate(MPSes):
				Env[i, oc] = (target[oc].H | t[oc] | Env[i, oc - 1]).contract()
				assert len(Env[i, oc].inds) == 2
		else:
			Tens = (
				Env[0, oc - 2] | MPSes[0][oc - 1] | MPSes[0][oc] | Env[0, oc + 1]
			).contract()
			for i, t in enumerate(MPSes[1:]):
				Tens += (
					Env[i + 1, oc - 2]
					| MPSes[i + 1][oc - 1]
					| MPSes[i + 1][oc]
					| Env[i + 1, oc + 1]
				).contract()
			n = len(MPSes[0][oc - 1].inds) - 1
			U, d, V = qtn.tensor_split(
				Tens, left_inds=Tens.inds[:n], cutoff=tol, absorb=None
			)
			V.drop_tags()
			for tag in target[oc].tags:
				V.add_tag(tag)
			target[oc] = V
			for i, t in enumerate(MPSes):
				Env[i, oc] = (target[oc].H | t[oc] | Env[i, oc + 1]).contract()
				assert len(Env[i, oc].inds) == 2

		oc += direction

		if oc == starting_oc:
			tags = target[oc].tags
			tmp = (Env[0, oc - 1] | MPSes[0][oc] | Env[0, oc + 1]).contract()
			for i, t in enumerate(MPSes[1:]):
				tmp += (Env[i + 1, oc - 1] | t[oc] | Env[i + 1, oc + 1]).contract()
			tmp.drop_tags()
			for tag in tags:
				tmp.add_tag(tag)
			target[oc] = tmp
			break
	out = target[oc] @ target[oc].H
	return out


def MPS_compressing_sum(
	MPSes: List[qtn.MatrixProductState], target_norm2: float, tol: float, crit: float
):
	# check free indices are compatible across all input MPS
	mps0 = MPSes[0]
	N = mps0.L
	tens_arr = [
		np.random.rand(4, 4, x.ind_size(mps0.site_ind_id.format(c)))
		for c, x in enumerate(mps0)
	]
	tens_arr[0] = tens_arr[0][0, :, :]
	tens_arr[-1] = tens_arr[-1][:, 0, :]
	for mpsi in MPSes[1:]:
		assert mpsi.L == N
		c = 0
		for x in mpsi:
			s = x.ind_size(mpsi.site_ind_id.format(c))
			assert s == tens_arr[c].shape[-1]
			c += 1
		mpsi.site_ind_id = mps0.site_ind_id

	# other shape format than lrp are buggy. it always convert to lrp, and it doesn't treat edge tensor correctly when converting.
	out = qtn.MatrixProductState(
		tens_arr, shape="lrp", site_ind_id=mps0.site_ind_id, site_tag_id="out{}"
	)
	oc = out.calc_current_orthog_center()
	if oc[0] == oc[1]:
		oc = oc[0]
	else:
		oc = out.L - 1
	envs = [mpsmps_env_prep(out, m) for m in MPSes]
	new_cost = 0
	direction = 1
	iter_count = 0
	while True:
		sum_sweep_out = sum_sweep(MPSes, out, envs, direction, tol, oc)
		new_cost = target_norm2 - sum_sweep_out
		if new_cost < crit:
			break
		iter_count += 1
		if iter_count > 1000:
			print("Compressing sum failed to converge")
			break
	return out


def MPS_compression(
	MPS: qtn.MatrixProductState, target_norm2: float, tol: float, crit: float
):
	return MPS_compressing_sum([MPS], target_norm2, tol, crit)
