"""
    Liouville-Lanczos: A library for Many-Body Green's function on quantum and classical computer.
    Copyright (C) 2024  Alexandre Foley

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""



"""
La stratégie à suivre: faire des mise à jour à deux sites,
le coté "arrière" est multiplié par la racinne quatrième de la somme des carré des valeurs singulière, 
le coté "avant" est contracté avec les valeurs singulière et divisé par la quatrième racine des la somme des carrées des valeur singulière.
Les tenseurs environnements doivent être normalisé de sorte à évité l'apparition de la norme total dans la mise à jours.

"""


class Env_holder:
	"""
	class to hold the MPTs that makes up the enviroments of a 1d-sweeping tensor algorithm.
	Takes care of the fiddling with the site index. The environment generated by the tensors at site i can be accessed by using [j,i] where j is the jth environment List
	"""

	def __init__(self, env):
		self.env = env

	def __getitem__(self, i: tuple[int, int]):
		i, j = i
		return self.env[i][j + 1]

	def __setitem__(self, i: tuple[int, int], value):
		i, j = i
		self.env[i][j + 1] = value


import quimb.tensor as qtn
from typing import List
import numpy as np
from .generate_simple_MPO import generate_id_MPO


def Nroots_prediction(norms: np.array) -> float:
	"""Compute the second order approximation to the Nth root of the product of the supplied list. Nth roots rapidly converge to 1 as N increase with finite precision arithmetic. This approximation should be more accurate than the direct computation with double precision floats"""
	# could be computed exactly using logarithms and exponentials... but it wouldn't save us from doing it repeatedly, and this is cheaper.
	av = np.mean(norms)
	deltas = norms - av
	N = len(norms)
	x = -np.sum(deltas**2)
	x = x / (av * N * (N - 1))
	return av + x


def guess_tensor_norm(target_norms, norm2, oc, direction):
	"""guess the N root of the norm of the MPO from the norms of the individual tensors and the norm of the update. The value converge exponentially fast in the network optimization procedure."""
	target_norms[oc] = norm2
	target_norms[oc + direction] = norm2
	target_norm_root = Nroots_prediction(
		target_norms
	)  ## doit être m-a-j avec les tenseur de target. L'algo suppose que target_norm_root^L est la norm du réseau cible.
	a = 1
	b = (norm2 < target_norm_root) * (
		np.abs(np.log(norm2 / target_norm_root))
	)  # when norm2 is small, it pays to reduce the norm faster.
	target_norm_root = (a * target_norm_root + b * norm2) / (
		a + b
	)  ##injecting the average to speedup norm distribution convergence, not using just it to reduce overshooting oscillation
	target_norms[oc] = target_norm_root
	target_norms[oc + direction] = target_norm_root
	norm = np.sqrt(target_norm_root)
	return norm


def compute_oc(MPO: qtn.MatrixProductOperator) -> tuple[int, int]:
	tmp_id = qtn.rand_uuid()
	forward = True
	center = [0, 0]
	for i, _ in enumerate(MPO):
		# il faut tout contracter sauf le lien.
		t = MPO[i]
		if forward and i == MPO.L - 1:
			center = [i, i]
			break
		if forward:
			bond_name = MPO.bond(i, i + 1)
			center[0] = i
		else:
			bond_name = MPO.bond(i - 1, i)
		tp = qtn.Tensor(t.H)
		tp.reindex_({bond_name: tmp_id})
		X = (t | tp).contract()
		is_center = not np.allclose(
			X.data / X.data.flatten()[0], np.eye(X.data.shape[0]), rtol=1.0e-12
		)
		if is_center:
			forward = False
			center[1] = i
	return tuple(center)


def move_oc(MPO: qtn.MatrixProductOperator, dest: int):
	if dest < 0:
		dest = MPO.L + dest
	assert dest < MPO.L
	assert dest >= 0
	oc = [*compute_oc(MPO)]
	while oc[0] < dest:
		t = MPO[oc[0]]
		bond = MPO.bond(oc[0], oc[0] + 1)
		u, d, v = t.split(left_inds=None, right_inds=[bond], absorb=None)
		dd = np.sqrt(d @ d)
		d /= dd
		dv = (d | v).contract(output_inds=v.inds)
		dv.drop_tags(dv.tags)
		MPO[oc[0]] = u * dd
		MPO[oc[0] + 1] = MPO[oc[0] + 1] @ dv
		oc[0] += 1
	while oc[1] > dest:
		t = MPO[oc[1]]
		bond = MPO.bond(oc[1] - 1, oc[1])
		u, d, v = t.split(left_inds=[bond], absorb=None)
		dd = np.sqrt(d @ d)
		d /= dd
		du = (d | u).contract(output_inds=u.inds)
		du.drop_tags(du.tags)
		MPO[oc[1] - 1] = MPO[oc[1] - 1] @ du
		MPO[oc[1]] = v * dd
		oc[1] -= 1


def sum_sweep(
	MPOs: List[qtn.MatrixProductOperator],
	target: qtn.MatrixProductOperator,
	envs,
	direction,
	tol,
	oc,
	target_norms,
	max_bond,
):

	Env = Env_holder(envs)
	starting_oc = oc
	L = target.L
	direction = 1
	if oc == L - 1:
		direction = -1
	count = 0
	while True:
		indexshift = (direction - 1) // 2
		Tens = (
			Env[0, oc + indexshift - 1]
			| MPOs[0][oc + indexshift]
			| MPOs[0][oc + indexshift + 1]
			| Env[0, oc + indexshift + 2]
		).contract()
		for i, t in enumerate(MPOs[1:]):
			Tens += (
				Env[i + 1, oc + indexshift - 1]
				| MPOs[i + 1][oc + indexshift]
				| MPOs[i + 1][oc + indexshift + 1]
				| Env[i + 1, oc + indexshift + 2]
			).contract()
		n = len(MPOs[0][oc + direction].inds) - 1
		if direction == 1:
			right_inds, left_inds = Tens.inds[-n:], None
		else:
			right_inds, left_inds = None, Tens.inds[:n]
		U, d, V = qtn.tensor_split(
			Tens,
			right_inds=right_inds,
			left_inds=left_inds,
			absorb=None,
			cutoff=tol,
			max_bond=max_bond,
		)
		if direction == 1:
			N = U
		else:
			N = V
		norm2 = np.sqrt(d @ d)
		norm = guess_tensor_norm(target_norms, norm2, oc, direction)
		N *= norm
		N.drop_tags()
		for tag in target[oc].tags:
			N.add_tag(tag)
		target[oc] = N  ## besoin d'adaptation pour gérer la norme
		for i, t in enumerate(MPOs):  ## besoin d'adaptation pour gérer la norme
			Env[i, oc] = (
				target[oc].H | t[oc] | Env[i, oc - direction]
			).contract() / norm**2
			assert len(Env[i, oc].inds) == 2

		oc += direction
		direction = direction(1 - 2 * (oc == (L - 1) or oc == 0))

		if oc == starting_oc:
			tags = target[oc].tags
			tmp = (Env[0, oc - 1] | MPOs[0][oc] | Env[0, oc + 1]).contract()
			for i, t in enumerate(MPOs[1:]):
				tmp += (Env[i + 1, oc - 1] | t[oc] | Env[i + 1, oc + 1]).contract()
			tmp.drop_tags()
			for tag in tags:
				tmp.add_tag(tag)
			target[oc] = tmp
			break
		count += 1
	out = target[oc] @ target[oc].H
	return out


def order_one_square_root(
	MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
	"""compute an order one approximation to the square root of MPO assuming its eigenvalues are in the domain [0,1].
	This approximation is better starting point for newton's method than order_two_square_root if it is known
	that no eigenvalues are close to zero."""
	zero = generate_id_MPO(MPO.lower_ind_id, MPO.upper_ind_id, MPO.L, factor=0.23570226)
	one = MPO * 2 * 0.40824829
	return MPO_compressing_sum([zero, one], tol, crit, max_bond)


def order_two_square_root(
	MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond
):
	"""compute an order two approximation to the square root of MPO assuming its eigenvalues are in the domain [0,1]
	This approximation sacrifice some precision far from zero to increase it near zero.
	Newton's procedure has trouble converging near zero. This compromise speeds up convergence near
	zero very significantly without sacrificing too much close to 1. In the Scalar case, about 8 iteration of newton's
	procedure is more than enough to converge the whole domain to an absolute and relative error of 1e-16.
	One must be careful to avoid division by zero when there are null eigenvalues. Typical pseudo-inverse methods should be safe."""
	one = 3.425800798515744 * MPO
	two = -2.6352313834736494 * MPO.apply(MPO)
	return MPO_compressing_sum([one, two], tol, crit, max_bond)


def cpt_sqrt_left_env(varL, cL, out, target, up_ind, dn_ind):
	##VARL update
	A, B, Ad, Bd, c = setup_index_left_sqrt_var(varL, out, target, up_ind, dn_ind)
	out_varL = (varL | B | Bd | Ad | A).contract()
	##cL update
	out_cL = (cL | c | Bd | Ad).contract()
	return out_varL, out_cL


def setup_index_left_sqrt_var(varL, out, target, up_ind, dn_ind):
	B = out.copy()
	left_ind = set(B.inds).intersection(varL.inds)
	right_ind = set(B.inds).difference([*left_ind, up_ind, dn_ind])
	A = out.copy()
	right_ind = right_ind.pop()
	A_reind = {up_ind: up_ind + "a", dn_ind: up_ind, right_ind: right_ind + "a"}
	Bd_reind = {up_ind: up_ind + "uad", right_ind: right_ind + "bd"}
	Ad_reind = {
		dn_ind: up_ind + "uad",
		up_ind: up_ind + "a",
		right_ind: right_ind + "ad",
	}
	if len(left_ind) == 1:  # not at boundary
		left_ind = left_ind.pop()
		A_reind[left_ind] = left_ind + "a"
		Bd_reind[left_ind] = left_ind + "bd"
		Ad_reind[left_ind] = left_ind + "ad"
	Ad = A.H
	A.reindex_(A_reind)
	Bd = B.H
	Bd.reindex_(Bd_reind)
	Ad.reindex_(Ad_reind)
	c = target.reindex({up_ind: up_ind + "a"})
	return A, B, Ad, Bd, c


def setup_index_right_sqrt_var(
	varR: qtn.Tensor, out: qtn.Tensor, target: qtn.Tensor, up_ind: str, dn_ind: str
):
	B = out.copy()
	right_ind = set(B.inds).intersection(varR.inds)
	left_ind = set(B.inds).difference([*right_ind, up_ind, dn_ind])
	assert len(right_ind) <= 1 and len(left_ind) == 1
	left_ind = left_ind.pop()
	A = out.copy()
	A_reind = {up_ind: up_ind + "a", dn_ind: up_ind, left_ind: left_ind + "a"}
	Bd_reind = {up_ind: up_ind + "uad", left_ind: left_ind + "bd"}
	Ad_reind = {dn_ind: up_ind + "uad", up_ind: up_ind + "a", left_ind: left_ind + "ad"}
	if len(right_ind) == 1:
		right_ind = right_ind.pop()
		A_reind[right_ind] = right_ind + "a"
		Bd_reind[right_ind] = right_ind + "bd"
		Ad_reind[right_ind] = right_ind + "ad"
	Ad = A.H
	A.reindex_(A_reind)
	Bd = B.H
	Bd.reindex_(Bd_reind)
	Ad.reindex_(Ad_reind)
	##cR update
	c = target.reindex({up_ind: up_ind + "a"})
	return A, B, Ad, Bd, c


def cpt_sqrt_right_env(varR, cR, out, target, up_ind, dn_ind):
	A, B, Ad, Bd, c = setup_index_right_sqrt_var(varR, out, target, up_ind, dn_ind)
	##VARR update
	out_varR = (varR | B | Bd | Ad | A).contract()
	##cR update
	out_cR = (cR | c | Bd | Ad).contract()
	return out_varR, out_cR


def init_sqrt_env(out, target, oc, up_ind: str, dn_ind: str, target_norms):
	varL = [qtn.Tensor()]
	cL = [qtn.Tensor()]
	i = 0
	while i < oc:
		vl, cl = cpt_sqrt_left_env(
			varL[-1],
			cL[-1],
			out[i] / target_norms[i],
			target[i],
			up_ind.format(i),
			dn_ind.format(i),
		)
		varL.append(vl)
		cL.append(cl)
		i += 1
	i = out.L - 1
	varR = [qtn.Tensor()]
	cR = [qtn.Tensor()]
	while i > oc:
		vr, cr = cpt_sqrt_right_env(
			varR[-1],
			cR[-1],
			out[i] / target_norms[i],
			target[i],
			up_ind.format(i),
			dn_ind.format(i),
		)
		varR.append(vr)
		cR.append(cr)
		i -= 1
	varR.reverse()
	cR.reverse()
	return Env_holder([[*varL, None, *varR]]), Env_holder([[*cL, None, *cR]])


def linsolve(T, C, precision):
	"""Penrose pseudo-inverse"""
	left_inds = set(T.inds).intersection(C.inds)
	U, d, V = qtn.tensor_split(T, left_inds=left_inds, absorb=None, cutoff=precision)
	dm = 1 / d  # penrose pseudo inverse
	cu, cd, cv = qtn.tensor_split(
		C,
		left_inds=set(V.inds).union(U.inds).intersection(C.inds),
		absorb=None,
		cutoff=None,
	)
	o_inds = set(T.inds).symmetric_difference(C.inds)
	O = (U.H | dm | V.H | C).contract(output_inds=o_inds)  # a/x_n
	return O


def sqrt_sweep(
	out: qtn.MatrixProductOperator,
	target,
	VarEnv,
	Cenv,
	oc,
	direction,
	target_norms,
	tol,
	max_bond,
):
	count = 0
	starting_oc = oc
	L = out.L
	while True:
		indexshift = (direction - 1) // 2
		up_indn = out.upper_ind_id.format(oc + indexshift)
		dn_indn = out.lower_ind_id.format(oc + indexshift)
		up_indnp = out.upper_ind_id.format(oc + indexshift + 1)
		dn_indnp = out.lower_ind_id.format(oc + indexshift + 1)
		vL = VarEnv[0, oc - 1 + indexshift]
		cL = Cenv[0, oc - 1 + indexshift]
		On = out[oc + indexshift]
		Onp = out[oc + indexshift + 1]
		tn = target[oc + indexshift]
		tnp = target[oc + indexshift + 1]
		vR = VarEnv[0, oc + 2 + indexshift]
		cR = Cenv[0, oc + 2 + indexshift]
		An, Bn, Adn, Bdn, cn = setup_index_left_sqrt_var(vL, On, tn, up_indn, dn_indn)
		Anp, Bnp, Adnp, Bdnp, cnp = setup_index_right_sqrt_var(
			vR, Onp, tnp, up_indnp, dn_indnp
		)
		T = (vL | Adn | An | Adnp | Anp | vR).contract()
		C = (cL | cn | Adn | Adnp | cnp | cR).contract()
		xn = (Bn | Bnp).contract()
		O = linsolve(T, C, tol)
		O = (O + xn) / 2
		out_left_inds = set(Bn.inds).difference(Bnp.inds)
		U, d, V = qtn.tensor_split(O, out_left_inds, absorb=None, cutoff=tol)
		norm2 = np.sqrt(d @ d)
		norm = guess_tensor_norm(target_norms, norm2, oc, direction)
		d /= norm
		U.drop_tags()
		V.drop_tags()
		d.drop_tags()
		for tag in out[oc + indexshift].tags:
			U.add_tag(tag)
		for tag in out[oc + 1 + indexshift].tags:
			V.add_tag(tag)
		if direction == 1:
			VarEnv[0, oc + indexshift], Cenv[0, oc + indexshift] = cpt_sqrt_left_env(
				vL, cL, U, target[oc + indexshift], up_indn, dn_indn
			)
			Cenv[0, oc + indexshift] /= norm**2
			V = (V | d).contract(output_inds=V.inds)
			U *= norm
		else:
			(
				VarEnv[0, oc + indexshift + 1],
				Cenv[0, oc + indexshift + 1],
			) = cpt_sqrt_right_env(
				vR, cR, V, target[oc + indexshift + 1], up_indnp, dn_indnp
			)
			Cenv[0, oc + indexshift + 1] /= norm**2
			U = (U | d).contract(output_inds=U.inds)
			V *= norm

		out[oc + indexshift] = U
		out[oc + indexshift + 1] = V

		oc += direction
		direction = direction - 2 * (oc == (L - 1) or oc == 0) * direction

		if oc == starting_oc:
			err = xn - O
			err = err @ err.H
			break
		count += 1
	return err


def Square_Root(
	MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None, out=None
):
	"""compute the square root of the supplied MPO using newton's iterative formula."""
	# first order solution:
	if out is None:
		out = order_two_square_root(MPO, tol, crit, max_bond)
	cost = 100000
	new_cost = 1000
	oc = compute_oc(out)
	if oc[1] == oc[0]:
		oc = oc[1]
	else:
		oc = 0
	if oc == out.L:
		direction = -1
	else:
		direction = 1
	norms = [x @ x.H for x in out]
	tgt_norm = np.mean(norms)
	varEnv, Cenv = init_sqrt_env(
		out, MPO, oc, out.upper_ind_id, out.lower_ind_id, target_norms=norms
	)
	iter_count = 0
	while (np.abs(new_cost - cost) > tol or cost > 1) and iter_count < 200:
		cost = new_cost
		new_cost = sqrt_sweep(
			out, MPO, varEnv, Cenv, oc, direction, norms, crit, max_bond
		)
		print(cost)
		iter_count += 1
	print(norms)
	return out


def Embed_in_unitaryMPO(
	MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
	inL = MPO.L
	outL = inL + 1
	P = qtn.Tensor(
		data=[[1, 0], [0, 0]],
		inds=(MPO.lower_ind_id.format(inL), MPO.upper_ind_id.format(inL)),
		tags=[MPO.site_tag_id.format(inL)],
	)
	Out = qtn.MPO_rand(outL, 4, 2, dtype=MPO.dtype)
	norms = [x @ x.H for x in Out]
	tgt_norm = np.mean(norms)
	# The next tree line accomplish this: MPOp = qtn.MatrixProductOperator(MPO|P)
	# wut keep the result in a MPO
	Nm1shape = MPO[-1].data.shape
	Nm1shape = (Nm1shape[0], 1, *Nm1shape[1:])
	MPOp = qtn.MatrixProductOperator(
		[
			*[MPO[i].data for i, t in enumerate(MPO.tensors[0:-1])],
			MPO[-1].data.reshape(Nm1shape),
			P.data.reshape(1, *P.data.shape),
		],
		lower_ind_id=MPO.lower_ind_id,
		upper_ind_id=MPO.upper_ind_id,
		site_tag_id=MPO.site_tag_id,
	)
	MPOenv = mpompo_env_prep(Out, MPOp, tgt_norm, 0)
	Pout = (Out | P).contract(P.tags)
	OOenv = mpompo_env_prep(
		Pout, Pout, tgt_norm, 0
	)  # No env contrib for the ancilla qbit.
	cost = 1.0e18
	new_cost = 0
	direction = 1
	iter_count = 0
	oc = 0
	while True:
		new_cost = Embed_sweep(
			MPOp, Out, OOenv, MPOenv, direction, tol, oc, norms, max_bond=max_bond
		)
		if abs(2 * (new_cost - cost) / (new_cost + cost)) < crit:
			break
		cost = new_cost
		iter_count += 1
		if iter_count > 1000:
			print("Compressing sum failed to converge")
			break
	print("iterations: ", iter_count)
	return Out


def Embed_sweep(MPOp, Out, OOenv, MPOEnv, direction, tol, oc, norms, max_bond):
	pass


def mpompo_env_prep(mpoA, mpoB, target_norm, oc):
	L = mpoA.L
	outleft = []
	outleft.append(qtn.Tensor(data=1, inds=()))
	for i in range(oc):
		outleft.append((outleft[-1] | mpoA[i].H | mpoB[i]).contract() / target_norm)
	outright = []
	outright.append(qtn.Tensor(data=1, inds=()))
	for i in range(L - 1, oc, -1):
		outright.append((outright[-1] | mpoA[i].H | mpoB[i]).contract() / target_norm)
	outright.reverse()
	return outleft + [qtn.Tensor()] + outright


def MPO_compressor(
	MPO: qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
	return MPO_compressing_sum([MPO], tol, crit, max_bond)

def MPOcs_assert_coherent_index_label(MPOs:List[qtn.MatrixProductOperator]):
	"""
	check that all the free indices are compatible across all input MPO,
	upon success, return a ready to optimize output MPO. 
	It is a minor optimization to bundle those two operation together.
	"""
	mpo0 = MPOs[0]
	N = mpo0.L
	tens_arr = [
		np.random.rand(
			4,
			4,
			mpo0[c].ind_size(mpo0.upper_ind_id.format(c)),
			mpo0[c].ind_size(mpo0.lower_ind_id.format(c)),
		)
		for c, x in enumerate(mpo0)
	]
	tens_arr[0] = tens_arr[0][0, :, :, :]
	tens_arr[-1] = tens_arr[-1][:, 0, :, :]
	mpsi_n = 0
	for mpsi in MPOs[1:]:
		assert mpsi.L == N
		c = 0
		while c < N:
			x = mpsi[c]
			sup = x.ind_size(mpsi.upper_ind_id.format(c))
			sdn = x.ind_size(mpsi.lower_ind_id.format(c))
			assert sup == tens_arr[c].shape[-2]
			assert sdn == tens_arr[c].shape[-1]
			c += 1
		mpsi.upper_ind_id = mpo0.upper_ind_id
		mpsi.lower_ind_id = mpo0.lower_ind_id
		mpsi_n += 1
	out = qtn.MatrixProductOperator(
		tens_arr,
		shape="lrud",
		upper_ind_id=mpo0.upper_ind_id,
		lower_ind_id=mpo0.lower_ind_id,
		site_tag_id="out{}",
	)
	return out


def MPO_compressing_sum(
	MPOs: List[qtn.MatrixProductOperator], tol: float, crit: float, max_bond=None
):
	out = MPOcs_assert_coherent_index_label(MPOs)
	mpo0 = MPOs[0]
	N = mpo0.L
	oc = compute_oc(MPOs[0])
	if oc[0] == oc[1]:
		oc = oc[0]
	else:
		oc = 0
	norms = [x @ x.H for x in out]
	tgt_norm = np.mean(norms)
	envs = [mpompo_env_prep(out, m, tgt_norm, oc) for m in MPOs]
	cost = 1.0e18 # A huge dummy value.
	new_cost = 0
	direction = 1
	iter_count = 0
	while True:
		new_cost = sum_sweep(
			MPOs, out, envs, direction, tol, oc, norms, max_bond=max_bond
		)
		if abs(2 * (new_cost - cost) / (new_cost + cost)) < crit:
			break
		cost = new_cost
		iter_count += 1
		if iter_count > 1000:
			print("Compressing sum failed to converge")
			break
	return out

def MPO_Liouville_assert_coherent_index_label(MPOs:List[qtn.MatrixProductOperator],density_matrix:qtn.MatrixProductOperator):
	"""
	check that all the free indices are compatible across all input MPO,
	upon success, return a ready to optimize output MPO. 
	"""
	N = density_matrix.L
	mpsi_n = 0
	for mpsi in MPOs[]:
		assert mpsi.L == N
		c = 0
		while c < N:
			x = mpsi[c]
			d = density_matrix[c]
			dup = d.ind_size(density_matrix.upper_ind_id.format(c))
			ddn = x.ind_size(density_matrix.lower_ind_id.format(c))
			sup = x.ind_size(mpsi.upper_ind_id.format(c))
			sdn = x.ind_size(mpsi.lower_ind_id.format(c))
			assert sup == ddn #compatibility for inner product
			assert sdn == dup #compatibility for inner product
			assert dup == ddn #density matrix is hermitian, this condition is a corrolary
			c += 1
		mpsi.upper_ind_id = MPOs[0].upper_ind_id
		mpsi.lower_ind_id = MPOs[0].lower_ind_id
		mpsi_n += 1
	return True

def random_MPO_from(mpo:qtn.MatrixProductOperator,periodic_boundary:bool=False):
	tens_arr = [
		np.random.rand(
			4,
			4,
			mpo[c].ind_size(mpo.upper_ind_id.format(c)),
			mpo[c].ind_size(mpo.lower_ind_id.format(c)),
		)
		for c, x in enumerate(mpo)
	]
	if not periodic_boundary:
		tens_arr[0] = tens_arr[0][0, :, :, :]
		tens_arr[-1] = tens_arr[-1][:, 0, :, :]
	out = qtn.MatrixProductOperator(
		tens_arr,
		shape="lrud",
		upper_ind_id=mpo.upper_ind_id,
		lower_ind_id=mpo.lower_ind_id,
		site_tag_id="out{}",
	)
	return out

def MPO_Liouville_compressing_sum(
	MPOs: List[qtn.MatrixProductOperator],Density_matrix:qtn.MatrixProductOperator, tol: float, crit: float, max_bond=None
):
	"""
	Compress the MPO with respect to the inner product $(A,B)_\rho = Tr[\rho(A^\dagger B + B A^\dagger)]$ where \rho is the supplied density matrix MPO.
	"""
	MPO_Liouville_assert_coherent_index_label(MPOs,Density_matrix)
	out = random_MPO_from(Density_matrix)
	mpo0 = MPOs[0]
	N = mpo0.L
	oc = compute_oc(MPOs[0])
	if oc[0] == oc[1]:
		oc = oc[0]
	else:
		oc = 0
	#got here
	norms = [x @ x.H for x in out]
	tgt_norm = np.mean(norms)
	envs = [mpompo_env_prep(out, m, tgt_norm, oc) for m in MPOs]
	cost = 1.0e18 # A huge dummy value.
	new_cost = 0
	direction = 1
	iter_count = 0
	while True:
		new_cost = sum_sweep(
			MPOs, out, envs, direction, tol, oc, norms, max_bond=max_bond
		)
		if abs(2 * (new_cost - cost) / (new_cost + cost)) < crit:
			break
		cost = new_cost
		iter_count += 1
		if iter_count > 1000:
			print("Compressing sum failed to converge")
			break
	return out


if __name__ == "__main__":
	pass
